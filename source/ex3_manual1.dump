Dump of assembler code for function Decode:
ex3b.c:
18	decode_return Decode(const uint8_t *loc) {
   0x00000000000015d0 <+0>:	f3 0f 1e fa	endbr64 

19	  decode_return ret;
20	  // once again special case the first byte
21	  if ((*loc & 0x80UL) == 0) {
   0x00000000000015d4 <+4>:	0f b6 07	movzbl (%rdi),%eax
   0x00000000000015d7 <+7>:	84 c0	test   %al,%al
   0x00000000000015d9 <+9>:	79 35	jns    0x1610 <Decode+64>

25	  }
26	  // load the next 64 bits of data which is big enough to always contain the next compressed integer
27	  uint64_t chunks = load64(loc);
   0x00000000000015db <+11>:	48 8b 07	mov    (%rdi),%rax

/usr/lib/gcc/x86_64-linux-gnu/11/include/bmi2intrin.h:
78	  return __builtin_ia32_pext_di (__X, __Y);
   0x00000000000015de <+14>:	48 ba 80 80 80 80 80 80 80 80	movabs $0x8080808080808080,%rdx
   0x00000000000015e8 <+24>:	c4 e2 fa f5 d2	pext   %rdx,%rax,%rdx

/usr/lib/gcc/x86_64-linux-gnu/11/include/bmiintrin.h:
168	  return __builtin_ia32_tzcnt_u64 (__X);
   0x00000000000015ed <+29>:	48 f7 d2	not    %rdx
   0x00000000000015f0 <+32>:	f3 48 0f bc d2	tzcnt  %rdx,%rdx

/usr/lib/gcc/x86_64-linux-gnu/11/include/bmi2intrin.h:
78	  return __builtin_ia32_pext_di (__X, __Y);
   0x00000000000015f5 <+37>:	48 63 f2	movslq %edx,%rsi
   0x00000000000015f8 <+40>:	48 8d 0d c1 0a 00 00	lea    0xac1(%rip),%rcx        # 0x20c0 <extract_masks>
   0x00000000000015ff <+47>:	ff c2	inc    %edx
   0x0000000000001601 <+49>:	48 63 d2	movslq %edx,%rdx
   0x0000000000001604 <+52>:	c4 e2 fa f5 04 f1	pext   (%rcx,%rsi,8),%rax,%rax

ex3b.c:
40	  return ret;
   0x000000000000160a <+58>:	c3	retq   
   0x000000000000160b <+59>:	0f 1f 44 00 00	nopl   0x0(%rax,%rax,1)

22	    ret.old_size = *loc > 0;
   0x0000000000001610 <+64>:	0f 95 c2	setne  %dl
   0x0000000000001613 <+67>:	0f b6 d2	movzbl %dl,%edx

23	    ret.difference = *loc;
24	    return ret;
   0x0000000000001616 <+70>:	c3	retq   
End of assembler dump.
