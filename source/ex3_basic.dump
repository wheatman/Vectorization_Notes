Dump of assembler code for function Decode:
ex3a.c:
12	decode_return Decode(const uint8_t *loc) {
   0x0000000000001547 <+0>:	f3 0f 1e fa	endbr64 
   0x000000000000154b <+4>:	55	push   %rbp
   0x000000000000154c <+5>:	48 89 e5	mov    %rsp,%rbp
   0x000000000000154f <+8>:	48 89 7d d8	mov    %rdi,-0x28(%rbp)

13	  // first check the case if we only use 1 byte by checking the top bit of the first byte
14	  // this is done becuase we need to special case what happens if we are 0
15	  decode_return ret;
16	  if ((*loc & 0x80UL) == 0) {
   0x0000000000001553 <+12>:	48 8b 45 d8	mov    -0x28(%rbp),%rax
   0x0000000000001557 <+16>:	0f b6 00	movzbl (%rax),%eax
   0x000000000000155a <+19>:	84 c0	test   %al,%al
   0x000000000000155c <+21>:	78 2b	js     0x1589 <Decode+66>

17	    ret.old_size = *loc > 0;
   0x000000000000155e <+23>:	48 8b 45 d8	mov    -0x28(%rbp),%rax
   0x0000000000001562 <+27>:	0f b6 00	movzbl (%rax),%eax
   0x0000000000001565 <+30>:	84 c0	test   %al,%al
   0x0000000000001567 <+32>:	0f 95 c0	setne  %al
   0x000000000000156a <+35>:	0f b6 c0	movzbl %al,%eax
   0x000000000000156d <+38>:	48 89 45 f8	mov    %rax,-0x8(%rbp)

18	    ret.difference = *loc;
   0x0000000000001571 <+42>:	48 8b 45 d8	mov    -0x28(%rbp),%rax
   0x0000000000001575 <+46>:	0f b6 00	movzbl (%rax),%eax
   0x0000000000001578 <+49>:	0f b6 c0	movzbl %al,%eax
   0x000000000000157b <+52>:	48 89 45 f0	mov    %rax,-0x10(%rbp)

19	    return ret;
   0x000000000000157f <+56>:	48 8b 45 f0	mov    -0x10(%rbp),%rax
   0x0000000000001583 <+60>:	48 8b 55 f8	mov    -0x8(%rbp),%rdx
   0x0000000000001587 <+64>:	eb 71	jmp    0x15fa <Decode+179>

20	  }
21	  ret.difference = *loc & 0x7FUL;
   0x0000000000001589 <+66>:	48 8b 45 d8	mov    -0x28(%rbp),%rax
   0x000000000000158d <+70>:	0f b6 00	movzbl (%rax),%eax
   0x0000000000001590 <+73>:	0f b6 c0	movzbl %al,%eax
   0x0000000000001593 <+76>:	83 e0 7f	and    $0x7f,%eax
   0x0000000000001596 <+79>:	48 89 45 f0	mov    %rax,-0x10(%rbp)

22	  ret.old_size = 1;
   0x000000000000159a <+83>:	48 c7 45 f8 01 00 00 00	movq   $0x1,-0x8(%rbp)

23	  uint64_t shift_amount = 7;
   0x00000000000015a2 <+91>:	48 c7 45 e8 07 00 00 00	movq   $0x7,-0x18(%rbp)

24	  // loop over each byte and shift the bits to the correct position
25	  do {
26	    loc += 1;
   0x00000000000015aa <+99>:	48 83 45 d8 01	addq   $0x1,-0x28(%rbp)

27	    ret.difference = ret.difference | ((*loc & 0x7FUL) << shift_amount);
   0x00000000000015af <+104>:	48 8b 75 f0	mov    -0x10(%rbp),%rsi
   0x00000000000015b3 <+108>:	48 8b 45 d8	mov    -0x28(%rbp),%rax
   0x00000000000015b7 <+112>:	0f b6 00	movzbl (%rax),%eax
   0x00000000000015ba <+115>:	0f b6 c0	movzbl %al,%eax
   0x00000000000015bd <+118>:	83 e0 7f	and    $0x7f,%eax
   0x00000000000015c0 <+121>:	48 89 c2	mov    %rax,%rdx
   0x00000000000015c3 <+124>:	48 8b 45 e8	mov    -0x18(%rbp),%rax
   0x00000000000015c7 <+128>:	89 c1	mov    %eax,%ecx
   0x00000000000015c9 <+130>:	48 d3 e2	shl    %cl,%rdx
   0x00000000000015cc <+133>:	48 89 d0	mov    %rdx,%rax
   0x00000000000015cf <+136>:	48 09 f0	or     %rsi,%rax
   0x00000000000015d2 <+139>:	48 89 45 f0	mov    %rax,-0x10(%rbp)

28	    ret.old_size += 1;
   0x00000000000015d6 <+143>:	48 8b 45 f8	mov    -0x8(%rbp),%rax
   0x00000000000015da <+147>:	48 83 c0 01	add    $0x1,%rax
   0x00000000000015de <+151>:	48 89 45 f8	mov    %rax,-0x8(%rbp)

29	    shift_amount += 7;
   0x00000000000015e2 <+155>:	48 83 45 e8 07	addq   $0x7,-0x18(%rbp)

30	  } while (*loc & 0x80UL);
   0x00000000000015e7 <+160>:	48 8b 45 d8	mov    -0x28(%rbp),%rax
   0x00000000000015eb <+164>:	0f b6 00	movzbl (%rax),%eax
   0x00000000000015ee <+167>:	84 c0	test   %al,%al
   0x00000000000015f0 <+169>:	78 b8	js     0x15aa <Decode+99>

31	  return ret;
   0x00000000000015f2 <+171>:	48 8b 45 f0	mov    -0x10(%rbp),%rax
   0x00000000000015f6 <+175>:	48 8b 55 f8	mov    -0x8(%rbp),%rdx

32	}
   0x00000000000015fa <+179>:	5d	pop    %rbp
   0x00000000000015fb <+180>:	c3	retq   
End of assembler dump.
