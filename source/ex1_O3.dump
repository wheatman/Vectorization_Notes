Dump of assembler code for function count_pairs:
ex1a.c:
7	count_pairs(uint16_t *data, uint64_t size, uint8_t target) {
   0x0000000000001630 <+0>:	f3 0f 1e fa	endbr64 

8	  uint64_t total = 0;
9	  uint16_t check = target | (target << 8U);
   0x0000000000001634 <+4>:	89 d1	mov    %edx,%ecx
   0x0000000000001636 <+6>:	0f b6 d2	movzbl %dl,%edx
   0x0000000000001639 <+9>:	c1 e1 08	shl    $0x8,%ecx
   0x000000000000163c <+12>:	09 d1	or     %edx,%ecx

10	  for (uint64_t i = 0; i < size; i++) {
   0x000000000000163e <+14>:	48 85 f6	test   %rsi,%rsi
   0x0000000000001641 <+17>:	74 25	je     0x1668 <count_pairs+56>
   0x0000000000001643 <+19>:	48 8d 34 77	lea    (%rdi,%rsi,2),%rsi
   0x0000000000001647 <+23>:	31 c0	xor    %eax,%eax
   0x0000000000001649 <+25>:	0f 1f 80 00 00 00 00	nopl   0x0(%rax)

11	    total += (data[i] == check);
   0x0000000000001650 <+32>:	31 d2	xor    %edx,%edx
   0x0000000000001652 <+34>:	66 39 0f	cmp    %cx,(%rdi)
   0x0000000000001655 <+37>:	0f 94 c2	sete   %dl
   0x0000000000001658 <+40>:	48 83 c7 02	add    $0x2,%rdi
   0x000000000000165c <+44>:	48 01 d0	add    %rdx,%rax

10	  for (uint64_t i = 0; i < size; i++) {
   0x000000000000165f <+47>:	48 39 fe	cmp    %rdi,%rsi
   0x0000000000001662 <+50>:	75 ec	jne    0x1650 <count_pairs+32>
   0x0000000000001664 <+52>:	c3	retq   
   0x0000000000001665 <+53>:	0f 1f 00	nopl   (%rax)
   0x0000000000001668 <+56>:	31 c0	xor    %eax,%eax

12	  }
13	  return total;
   0x000000000000166a <+58>:	c3	retq   
End of assembler dump.
