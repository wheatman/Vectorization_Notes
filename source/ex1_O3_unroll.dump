Dump of assembler code for function count_pairs:
ex1a.c:
7	count_pairs(uint16_t *data, uint64_t size, uint8_t target) {
   0x00000000000019c0 <+0>:	f3 0f 1e fa	endbr64 

8	  uint64_t total = 0;
9	  uint16_t check = target | (target << 8U);
   0x00000000000019c4 <+4>:	89 d0	mov    %edx,%eax
   0x00000000000019c6 <+6>:	c1 e2 08	shl    $0x8,%edx
   0x00000000000019c9 <+9>:	0f b6 c8	movzbl %al,%ecx
   0x00000000000019cc <+12>:	09 ca	or     %ecx,%edx

10	  for (uint64_t i = 0; i < size; i++) {
   0x00000000000019ce <+14>:	48 85 f6	test   %rsi,%rsi
   0x00000000000019d1 <+17>:	0f 84 41 01 00 00	je     0x1b18 <count_pairs+344>
   0x00000000000019d7 <+23>:	4c 8d 0c 77	lea    (%rdi,%rsi,2),%r9
   0x00000000000019db <+27>:	48 8d 74 36 fe	lea    -0x2(%rsi,%rsi,1),%rsi
   0x00000000000019e0 <+32>:	45 31 c0	xor    %r8d,%r8d
   0x00000000000019e3 <+35>:	48 d1 ee	shr    %rsi
   0x00000000000019e6 <+38>:	48 83 c6 01	add    $0x1,%rsi
   0x00000000000019ea <+42>:	83 e6 07	and    $0x7,%esi
   0x00000000000019ed <+45>:	0f 84 8e 00 00 00	je     0x1a81 <count_pairs+193>
   0x00000000000019f3 <+51>:	48 83 fe 01	cmp    $0x1,%rsi
   0x00000000000019f7 <+55>:	74 72	je     0x1a6b <count_pairs+171>
   0x00000000000019f9 <+57>:	48 83 fe 02	cmp    $0x2,%rsi
   0x00000000000019fd <+61>:	74 5c	je     0x1a5b <count_pairs+155>
   0x00000000000019ff <+63>:	48 83 fe 03	cmp    $0x3,%rsi
   0x0000000000001a03 <+67>:	74 47	je     0x1a4c <count_pairs+140>
   0x0000000000001a05 <+69>:	48 83 fe 04	cmp    $0x4,%rsi
   0x0000000000001a09 <+73>:	74 32	je     0x1a3d <count_pairs+125>
   0x0000000000001a0b <+75>:	48 83 fe 05	cmp    $0x5,%rsi
   0x0000000000001a0f <+79>:	74 1b	je     0x1a2c <count_pairs+108>
   0x0000000000001a11 <+81>:	48 83 fe 06	cmp    $0x6,%rsi
   0x0000000000001a15 <+85>:	0f 85 e5 00 00 00	jne    0x1b00 <count_pairs+320>

11	    total += (data[i] == check);
   0x0000000000001a1b <+91>:	45 31 d2	xor    %r10d,%r10d
   0x0000000000001a1e <+94>:	66 39 17	cmp    %dx,(%rdi)
   0x0000000000001a21 <+97>:	41 0f 94 c2	sete   %r10b
   0x0000000000001a25 <+101>:	48 83 c7 02	add    $0x2,%rdi
   0x0000000000001a29 <+105>:	4d 01 d0	add    %r10,%r8
   0x0000000000001a2c <+108>:	45 31 db	xor    %r11d,%r11d
   0x0000000000001a2f <+111>:	66 39 17	cmp    %dx,(%rdi)
   0x0000000000001a32 <+114>:	41 0f 94 c3	sete   %r11b
   0x0000000000001a36 <+118>:	48 83 c7 02	add    $0x2,%rdi
   0x0000000000001a3a <+122>:	4d 01 d8	add    %r11,%r8
   0x0000000000001a3d <+125>:	31 c0	xor    %eax,%eax
   0x0000000000001a3f <+127>:	66 39 17	cmp    %dx,(%rdi)
   0x0000000000001a42 <+130>:	0f 94 c0	sete   %al
   0x0000000000001a45 <+133>:	48 83 c7 02	add    $0x2,%rdi
   0x0000000000001a49 <+137>:	49 01 c0	add    %rax,%r8
   0x0000000000001a4c <+140>:	31 c9	xor    %ecx,%ecx
   0x0000000000001a4e <+142>:	66 39 17	cmp    %dx,(%rdi)
   0x0000000000001a51 <+145>:	0f 94 c1	sete   %cl
   0x0000000000001a54 <+148>:	48 83 c7 02	add    $0x2,%rdi
   0x0000000000001a58 <+152>:	49 01 c8	add    %rcx,%r8
   0x0000000000001a5b <+155>:	31 f6	xor    %esi,%esi
   0x0000000000001a5d <+157>:	66 39 17	cmp    %dx,(%rdi)
   0x0000000000001a60 <+160>:	40 0f 94 c6	sete   %sil
   0x0000000000001a64 <+164>:	48 83 c7 02	add    $0x2,%rdi
   0x0000000000001a68 <+168>:	49 01 f0	add    %rsi,%r8
   0x0000000000001a6b <+171>:	45 31 d2	xor    %r10d,%r10d
   0x0000000000001a6e <+174>:	66 39 17	cmp    %dx,(%rdi)
   0x0000000000001a71 <+177>:	41 0f 94 c2	sete   %r10b
   0x0000000000001a75 <+181>:	48 83 c7 02	add    $0x2,%rdi
   0x0000000000001a79 <+185>:	4d 01 d0	add    %r10,%r8

10	  for (uint64_t i = 0; i < size; i++) {
   0x0000000000001a7c <+188>:	49 39 f9	cmp    %rdi,%r9
   0x0000000000001a7f <+191>:	74 73	je     0x1af4 <count_pairs+308>

11	    total += (data[i] == check);
   0x0000000000001a81 <+193>:	45 31 db	xor    %r11d,%r11d
   0x0000000000001a84 <+196>:	66 39 17	cmp    %dx,(%rdi)
   0x0000000000001a87 <+199>:	41 0f 94 c3	sete   %r11b
   0x0000000000001a8b <+203>:	4d 01 c3	add    %r8,%r11
   0x0000000000001a8e <+206>:	45 31 c0	xor    %r8d,%r8d
   0x0000000000001a91 <+209>:	66 39 57 02	cmp    %dx,0x2(%rdi)
   0x0000000000001a95 <+213>:	41 0f 94 c0	sete   %r8b
   0x0000000000001a99 <+217>:	31 c0	xor    %eax,%eax
   0x0000000000001a9b <+219>:	4d 01 c3	add    %r8,%r11
   0x0000000000001a9e <+222>:	66 39 57 04	cmp    %dx,0x4(%rdi)
   0x0000000000001aa2 <+226>:	0f 94 c0	sete   %al
   0x0000000000001aa5 <+229>:	31 c9	xor    %ecx,%ecx
   0x0000000000001aa7 <+231>:	49 01 c3	add    %rax,%r11
   0x0000000000001aaa <+234>:	66 39 57 06	cmp    %dx,0x6(%rdi)
   0x0000000000001aae <+238>:	0f 94 c1	sete   %cl
   0x0000000000001ab1 <+241>:	31 f6	xor    %esi,%esi
   0x0000000000001ab3 <+243>:	49 01 cb	add    %rcx,%r11
   0x0000000000001ab6 <+246>:	66 39 57 08	cmp    %dx,0x8(%rdi)
   0x0000000000001aba <+250>:	40 0f 94 c6	sete   %sil
   0x0000000000001abe <+254>:	45 31 d2	xor    %r10d,%r10d
   0x0000000000001ac1 <+257>:	49 01 f3	add    %rsi,%r11
   0x0000000000001ac4 <+260>:	66 39 57 0a	cmp    %dx,0xa(%rdi)
   0x0000000000001ac8 <+264>:	41 0f 94 c2	sete   %r10b
   0x0000000000001acc <+268>:	45 31 c0	xor    %r8d,%r8d
   0x0000000000001acf <+271>:	4d 01 d3	add    %r10,%r11
   0x0000000000001ad2 <+274>:	66 39 57 0c	cmp    %dx,0xc(%rdi)
   0x0000000000001ad6 <+278>:	41 0f 94 c0	sete   %r8b
   0x0000000000001ada <+282>:	4d 01 c3	add    %r8,%r11
   0x0000000000001add <+285>:	45 31 c0	xor    %r8d,%r8d
   0x0000000000001ae0 <+288>:	66 39 57 0e	cmp    %dx,0xe(%rdi)
   0x0000000000001ae4 <+292>:	41 0f 94 c0	sete   %r8b
   0x0000000000001ae8 <+296>:	48 83 c7 10	add    $0x10,%rdi
   0x0000000000001aec <+300>:	4d 01 d8	add    %r11,%r8

10	  for (uint64_t i = 0; i < size; i++) {
   0x0000000000001aef <+303>:	49 39 f9	cmp    %rdi,%r9
   0x0000000000001af2 <+306>:	75 8d	jne    0x1a81 <count_pairs+193>
   0x0000000000001af4 <+308>:	4c 89 c0	mov    %r8,%rax
   0x0000000000001af7 <+311>:	c3	retq   
   0x0000000000001af8 <+312>:	0f 1f 84 00 00 00 00 00	nopl   0x0(%rax,%rax,1)

11	    total += (data[i] == check);
   0x0000000000001b00 <+320>:	45 31 c0	xor    %r8d,%r8d
   0x0000000000001b03 <+323>:	66 39 17	cmp    %dx,(%rdi)
   0x0000000000001b06 <+326>:	41 0f 94 c0	sete   %r8b

10	  for (uint64_t i = 0; i < size; i++) {
   0x0000000000001b0a <+330>:	48 83 c7 02	add    $0x2,%rdi
   0x0000000000001b0e <+334>:	e9 08 ff ff ff	jmpq   0x1a1b <count_pairs+91>
   0x0000000000001b13 <+339>:	0f 1f 44 00 00	nopl   0x0(%rax,%rax,1)
   0x0000000000001b18 <+344>:	45 31 c0	xor    %r8d,%r8d

12	  }
13	  return total;
   0x0000000000001b1b <+347>:	4c 89 c0	mov    %r8,%rax
   0x0000000000001b1e <+350>:	c3	retq   
End of assembler dump.
